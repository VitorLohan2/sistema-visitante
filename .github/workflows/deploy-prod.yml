name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag para deploy (ex: v1.2.3). Se vazio, cria nova tag automaticamente."
        required: false
      skip_build:
        description: "Pular build e usar imagem existente?"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

permissions:
  contents: write

env:
  DEPLOY_PATH: /home/dev/sistema/prod
  COMPOSE_FILE: docker-compose-prod.yml

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 1: Auto Tag - Gera vers√£o sem√¢ntica automaticamente
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  auto-tag:
    name: üè∑Ô∏è Auto Semantic Version
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
      is_new_tag: ${{ steps.set-tag.outputs.is_new_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Get latest tag
        id: get-latest
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "üìå √öltima tag: $LATEST_TAG"

      - name: Determine next version
        id: set-tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
        run: |
          # Se uma tag foi fornecida manualmente, usa ela
          if [ -n "$INPUT_TAG" ]; then
            echo "üìå Usando tag manual: $INPUT_TAG"
            echo "tag=$INPUT_TAG" >> $GITHUB_OUTPUT
            echo "is_new_tag=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          LATEST=${{ steps.get-latest.outputs.LATEST_TAG }}
          MAJOR=$(echo $LATEST | cut -d. -f1 | sed 's/v//')
          MINOR=$(echo $LATEST | cut -d. -f2)
          PATCH=$(echo $LATEST | cut -d. -f3)

          # Busca commits desde a √∫ltima tag
          COMMITS=$(git log $LATEST..HEAD --pretty=%B 2>/dev/null || echo "")

          # Se n√£o houver commits novos, reutiliza a √∫ltima tag
          if [ -z "$COMMITS" ]; then
            echo "‚ö†Ô∏è Nenhum commit novo desde $LATEST"
            echo "tag=$LATEST" >> $GITHUB_OUTPUT
            echo "is_new_tag=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Incrementa vers√£o conforme tipo de commit
          if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|^major:"; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -qiE "^feat:|^feature:"; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"

          # Verifica se a tag j√° existe
          while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
            echo "‚ö†Ô∏è Tag $NEW_TAG j√° existe, incrementando patch..."
            PATCH=$((PATCH + 1))
            NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          done

          echo "üè∑Ô∏è Nova tag: $NEW_TAG"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "is_new_tag=true" >> $GITHUB_OUTPUT

          # Cria e envia a tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $NEW_TAG -m "Release $NEW_TAG - Auto-generated"
          git push origin $NEW_TAG

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 2: Build - Constr√≥i e envia imagem Docker
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  build-and-push:
    name: üê≥ Build & Push Docker
    needs: auto-tag
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_build != 'true' }}
    outputs:
      tag: ${{ needs.auto-tag.outputs.tag }}
      image: ${{ steps.build.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push
        id: build
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          IMAGE="${{ secrets.DOCKER_USERNAME }}/liberae"

          echo "üèóÔ∏è Building: $IMAGE:$TAG"

          docker build \
            --cache-from type=registry,ref=$IMAGE:latest \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t "$IMAGE:$TAG" \
            -t "$IMAGE:latest" \
            ./backend

          docker push "$IMAGE:$TAG"
          docker push "$IMAGE:latest"

          echo "image=$IMAGE:$TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Imagem publicada: $IMAGE:$TAG"

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 3: Deploy - Faz deploy autom√°tico na VM de produ√ß√£o
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  deploy-prod:
    name: üöÄ Deploy Production
    needs: [auto-tag, build-and-push]
    if: ${{ always() && needs.auto-tag.result == 'success' && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped') }}
    runs-on: self-hosted
    steps:
      - name: Atualizar .env com nova tag
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"

          echo "üìù Atualizando .env com IMAGE_TAG=$TAG"

          # Cria/atualiza o .env apenas com as vari√°veis do Docker
          cat > ${{ env.DEPLOY_PATH }}/.env << EOF
          DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
          IMAGE_TAG=${TAG}
          EOF

          chmod 600 ${{ env.DEPLOY_PATH }}/.env

          echo "‚úÖ .env atualizado:"
          cat ${{ env.DEPLOY_PATH }}/.env

      - name: Deploy containers
        working-directory: ${{ env.DEPLOY_PATH }}
        run: |
          set -e

          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üöÄ INICIANDO DEPLOY - ${{ needs.auto-tag.outputs.tag }}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

          # Carrega vari√°veis do .env
          set -a
          source .env
          set +a

          echo "üì¶ Imagem: ${DOCKER_USERNAME}/liberae:${IMAGE_TAG}"

          # Para containers (mant√©m banco de dados)
          echo "üîΩ Parando container backend..."
          docker compose -f docker-compose-prod.yml stop backend || true
          docker compose -f docker-compose-prod.yml rm -f backend || true

          # Baixa nova imagem
          echo "‚¨áÔ∏è Baixando nova imagem..."
          docker compose -f docker-compose-prod.yml pull backend

          # Sobe containers
          echo "üöÄ Iniciando containers..."
          docker compose -f docker-compose-prod.yml up -d

          # Aguarda containers
          echo "‚è≥ Aguardando containers..."
          sleep 10

          # Verifica status
          echo "üìä Status dos containers:"
          docker compose -f docker-compose-prod.yml ps

          # Limpa imagens antigas
          echo "üßπ Limpando imagens n√£o utilizadas..."
          docker image prune -f

          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚úÖ DEPLOY CONCLU√çDO - ${DOCKER_USERNAME}/liberae:${IMAGE_TAG}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      - name: Health Check
        run: |
          echo "üè• Verificando sa√∫de da aplica√ß√£o..."
          sleep 5

          for i in {1..5}; do
            if curl -sf http://localhost:3707/health > /dev/null 2>&1; then
              echo "‚úÖ Backend respondendo!"
              exit 0
            fi
            echo "‚è≥ Tentativa $i/5 - Aguardando backend..."
            sleep 5
          done

          echo "‚ö†Ô∏è Backend pode estar demorando para iniciar (mas deploy foi conclu√≠do)"
