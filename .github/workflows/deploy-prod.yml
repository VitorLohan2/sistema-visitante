#TESTE
name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag para deploy (ex: v1.2.3). Se preenchido, farÃ¡ deploy dessa tag.'
        required: false

permissions:
  contents: write  # ðŸ”‘ Permite criar e enviar tags (necessÃ¡rio para o git push)

jobs:
  auto-tag:
    name: Auto Semantic Version Tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # necessÃ¡rio para ver tags
          persist-credentials: true  # mantÃ©m o GITHUB_TOKEN para push

      - name: Get latest tag
        id: get-latest
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 || echo "v0.0.0")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Determine next version
        id: set-tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # garante autenticaÃ§Ã£o
        run: |
          LATEST=${{ steps.get-latest.outputs.LATEST_TAG }}
          MAJOR=$(echo $LATEST | cut -d. -f1 | sed 's/v//')
          MINOR=$(echo $LATEST | cut -d. -f2)
          PATCH=$(echo $LATEST | cut -d. -f3)

          # Busca commits desde a Ãºltima tag
          COMMITS=$(git log $LATEST..HEAD --pretty=%B)

          # Incrementa version conforme tipo de commit
          if echo "$COMMITS" | grep -q -E "BREAKING CHANGE|major:"; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -qE "^feat:"; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

          # Configura Git e envia a tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag $NEW_TAG
          git push origin $NEW_TAG

  build-and-push:
    name: Build and Push Docker Image
    needs: auto-tag
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ needs.auto-tag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Build and Push Docker Image
        run: |
          IMAGE="${{ secrets.DOCKER_USERNAME }}/liberae:${{ needs.auto-tag.outputs.tag }}"
          echo "ðŸ—ï¸ Building $IMAGE"
          docker build -t "$IMAGE" ./backend
          docker push "$IMAGE"

  deploy-prod:
    name: Deploy to Production Server
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - name: Criar arquivo .deploy_env com variÃ¡veis
        run: |
          TAG="${{ needs.build-and-push.outputs.tag }}"
          echo "IMAGE_TAG=$TAG" > /home/dev/sistema/prod/.deploy_env
          echo "DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}" >> /home/dev/sistema/prod/.deploy_env
          chmod 600 /home/dev/sistema/prod/.deploy_env
          echo "âœ… .deploy_env criado com sucesso:"
          cat /home/dev/sistema/prod/.deploy_env

      - name: Deploy na produÃ§Ã£o (EC2)
        working-directory: /home/dev/sistema/prod
        run: |
          set -e
          set -a
          source /home/dev/sistema/prod/.deploy_env
          set +a

          echo "ðŸš€ Fazendo deploy da imagem: ${DOCKER_USERNAME}/liberae:${IMAGE_TAG}"

          docker compose -f docker-compose-prod.yml down
          docker compose -f docker-compose-prod.yml pull
          docker compose -f docker-compose-prod.yml up -d
          docker image prune -f

          echo "âœ… Deploy de produÃ§Ã£o concluÃ­do com sucesso!"
