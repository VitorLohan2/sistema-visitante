name: Deploy Control iD Service

on:
  push:
    branches:
      - main
    paths:
      - "controlid-service/**"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag para deploy (ex: v1.0.0). Se vazio, incrementa automaticamente."
        required: false

permissions:
  contents: write

env:
  DEPLOY_PATH: /home/dev/sistema/prod
  COMPOSE_FILE: docker-compose-prod.yml

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 1: Auto Tag - Gera versÃ£o semÃ¢ntica automaticamente
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  auto-tag:
    name: ðŸ·ï¸ Auto Version Control iD
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
      is_new_tag: ${{ steps.set-tag.outputs.is_new_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Get latest controlid tag
        id: get-latest
        run: |
          # Busca a Ãºltima tag especÃ­fica do controlid-service
          LATEST_TAG=$(git tag -l "controlid-v*" --sort=-v:refname | head -n1 || echo "")
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="controlid-v0.0.0"
          fi
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Ãšltima tag Control iD: $LATEST_TAG"

      - name: Determine next version
        id: set-tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_TAG: ${{ github.event.inputs.tag }}
        run: |
          # Se uma tag foi fornecida manualmente, usa ela
          if [ -n "$INPUT_TAG" ]; then
            # Adiciona prefixo se nÃ£o tiver
            if [[ "$INPUT_TAG" != controlid-* ]]; then
              INPUT_TAG="controlid-$INPUT_TAG"
            fi
            echo "ðŸ“Œ Usando tag manual: $INPUT_TAG"
            echo "tag=$INPUT_TAG" >> $GITHUB_OUTPUT
            echo "is_new_tag=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          LATEST=${{ steps.get-latest.outputs.LATEST_TAG }}
          # Remove o prefixo controlid-v para extrair a versÃ£o
          VERSION=$(echo $LATEST | sed 's/controlid-v//')
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)

          # Busca commits no diretÃ³rio controlid-service desde a Ãºltima tag
          if git rev-parse "$LATEST" >/dev/null 2>&1; then
            COMMITS=$(git log $LATEST..HEAD --pretty=%B -- controlid-service/ 2>/dev/null || echo "")
          else
            COMMITS=$(git log --pretty=%B -- controlid-service/ 2>/dev/null | head -20 || echo "initial")
          fi

          # Se nÃ£o houver commits novos, reutiliza a Ãºltima tag
          if [ -z "$COMMITS" ]; then
            echo "âš ï¸ Nenhum commit novo desde $LATEST"
            echo "tag=$LATEST" >> $GITHUB_OUTPUT
            echo "is_new_tag=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Incrementa versÃ£o conforme tipo de commit
          if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|^major:"; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -qiE "^feat:|^feature:"; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_TAG="controlid-v${MAJOR}.${MINOR}.${PATCH}"

          # Verifica se a tag jÃ¡ existe
          while git rev-parse "$NEW_TAG" >/dev/null 2>&1; do
            echo "âš ï¸ Tag $NEW_TAG jÃ¡ existe, incrementando patch..."
            PATCH=$((PATCH + 1))
            NEW_TAG="controlid-v${MAJOR}.${MINOR}.${PATCH}"
          done

          echo "ðŸ·ï¸ Nova tag: $NEW_TAG"
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "is_new_tag=true" >> $GITHUB_OUTPUT

          # Cria e envia a tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a $NEW_TAG -m "Release $NEW_TAG - Control iD Service"
          git push origin $NEW_TAG

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 2: Build e Push da imagem Docker
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-and-push:
    name: ðŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: auto-tag
    outputs:
      image_tag: ${{ needs.auto-tag.outputs.tag }}
    steps:
      - name: Checkout do cÃ³digo
        uses: actions/checkout@v4

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build e Push da imagem
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          # Remove o prefixo controlid- para a tag da imagem Docker
          DOCKER_TAG=$(echo $TAG | sed 's/controlid-//')
          IMAGE="${{ secrets.DOCKER_USERNAME }}/controlid-service"

          echo "ðŸ—ï¸ Building: $IMAGE:$DOCKER_TAG"

          docker build \
            --cache-from type=registry,ref=$IMAGE:latest \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t "$IMAGE:$DOCKER_TAG" \
            -t "$IMAGE:latest" \
            ./controlid-service

          docker push "$IMAGE:$DOCKER_TAG"
          docker push "$IMAGE:latest"

          echo "âœ… Imagem publicada: $IMAGE:$DOCKER_TAG"

      - name: Resumo do Build
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          DOCKER_TAG=$(echo $TAG | sed 's/controlid-//')
          echo "## ðŸ³ Build Control iD Service" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Imagem | \`${{ secrets.DOCKER_USERNAME }}/controlid-service\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | \`$DOCKER_TAG\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Git Tag | \`$TAG\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JOB 3: Deploy na VM (self-hosted runner)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: ðŸš€ Deploy to Production
    runs-on: self-hosted
    needs: [auto-tag, build-and-push]
    if: ${{ always() && needs.auto-tag.result == 'success' && needs.build-and-push.result == 'success' }}
    steps:
      - name: Atualizar .env com tag do Control iD
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          # Remove o prefixo controlid- para a tag da imagem Docker
          DOCKER_TAG=$(echo $TAG | sed 's/controlid-//')

          echo "ðŸ“ Atualizando .env com CONTROLID_IMAGE_TAG=$DOCKER_TAG"

          # Verifica se o arquivo .env existe
          if [ ! -f "${{ env.DEPLOY_PATH }}/.env" ]; then
            echo "âš ï¸ Arquivo .env nÃ£o encontrado, criando..."
            touch "${{ env.DEPLOY_PATH }}/.env"
          fi

          # Remove linha antiga se existir e adiciona a nova
          sed -i '/^CONTROLID_IMAGE_TAG=/d' "${{ env.DEPLOY_PATH }}/.env"
          echo "CONTROLID_IMAGE_TAG=${DOCKER_TAG}" >> "${{ env.DEPLOY_PATH }}/.env"

          chmod 600 "${{ env.DEPLOY_PATH }}/.env"

          echo "âœ… .env atualizado:"
          cat "${{ env.DEPLOY_PATH }}/.env"

      - name: Deploy container Control iD Service
        working-directory: ${{ env.DEPLOY_PATH }}
        run: |
          set -e

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸš€ INICIANDO DEPLOY CONTROL iD - ${{ needs.auto-tag.outputs.tag }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          # Carrega variÃ¡veis do .env
          set -a
          source .env
          set +a

          echo "ðŸ“¦ Imagem: ${DOCKER_USERNAME}/controlid-service:${CONTROLID_IMAGE_TAG}"

          # Verifica se o serviÃ§o existe no compose
          if ! grep -q "controlid-service" ${{ env.COMPOSE_FILE }}; then
            echo "âš ï¸ ServiÃ§o controlid-service nÃ£o encontrado no docker-compose!"
            echo "Por favor, adicione o serviÃ§o ao docker-compose-prod.yml"
            exit 1
          fi

          # Para e remove container antigo
          echo "ðŸ”½ Parando container controlid-service..."
          docker compose -f ${{ env.COMPOSE_FILE }} stop controlid-service || true
          docker compose -f ${{ env.COMPOSE_FILE }} rm -f controlid-service || true

          # Baixa nova imagem
          echo "â¬‡ï¸ Baixando nova imagem..."
          docker compose -f ${{ env.COMPOSE_FILE }} pull controlid-service

          # Sobe container
          echo "ðŸš€ Iniciando container..."
          docker compose -f ${{ env.COMPOSE_FILE }} up -d controlid-service

          # Aguarda container
          echo "â³ Aguardando container..."
          sleep 10

          # Verifica status
          echo "ðŸ“Š Status do container:"
          docker compose -f ${{ env.COMPOSE_FILE }} ps controlid-service

          # Limpa imagens antigas
          echo "ðŸ§¹ Limpando imagens nÃ£o utilizadas..."
          docker image prune -f

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… DEPLOY CONCLUÃDO - ${DOCKER_USERNAME}/controlid-service:${CONTROLID_IMAGE_TAG}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Health Check
        working-directory: ${{ env.DEPLOY_PATH }}
        run: |
          echo "ðŸ¥ Verificando saÃºde do Control iD Service..."
          sleep 5

          for i in {1..6}; do
            # Health check via rede Docker (porta nÃ£o exposta para host)
            if docker exec nginx_prod wget -qO- http://controlid-service:3050/health 2>/dev/null | grep -q '"success":true'; then
              echo "âœ… Control iD Service respondendo!"
              docker exec nginx_prod wget -qO- http://controlid-service:3050/health
              echo ""
              exit 0
            fi
            echo "â³ Tentativa $i/6 - Aguardando Control iD Service..."
            sleep 10
          done

          echo "âŒ Health check falhou apÃ³s 60s"
          docker compose -f ${{ env.COMPOSE_FILE }} logs controlid-service --tail=50
          exit 1

      - name: Resumo do Deploy
        if: success()
        run: |
          TAG="${{ needs.auto-tag.outputs.tag }}"
          DOCKER_TAG=$(echo $TAG | sed 's/controlid-//')
          echo "## ðŸš€ Deploy Control iD Service" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Deploy realizado com sucesso!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Valor |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| ServiÃ§o | Control iD Microservice |" >> $GITHUB_STEP_SUMMARY
          echo "| Git Tag | \`$TAG\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Tag | \`$DOCKER_TAG\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Path | \`${{ env.DEPLOY_PATH }}\` |" >> $GITHUB_STEP_SUMMARY
